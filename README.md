Engineering materials
====

This repository contains engineering materials of a self-driven vehicle's model participating in the WRO Future Engineers competition in the season 2022.

## Content

* `t-photos` contains 2 photos of the team (an official one and one funny photo with all team members)
* `v-photos` contains 6 photos of the vehicle (from every side, from top and bottom)
* `video` contains the video.md file with the link to a video where driving demonstration exists
* `schemes` contains one or several schematic diagrams in form of JPEG, PNG or PDF of the electromechanical components illustrating all the elements (electronic components and motors) used in the vehicle and how they connect to each other.
* `src` contains code of control software for all components which were programmed to participate in the competition
* `models` is for the files for models used by 3D printers, laser cutting machines and CNC machines to produce the vehicle elements. If there is nothing to add to this location, the directory can be removed.
* `other` is for other files which can be used to understand how to prepare the vehicle for the competition. It may include documentation how to connect to a SBC/SBM and upload files there, datasets, hardware specifications, communication protocols descriptions etc. If there is nothing to add to this location, the directory can be removed.

## Introduction

_This part must be filled by participants with the technical clarifications about the code: which modules the code consists of, how they are related to the electromechanical components of the vehicle, and what is the process to build/compile/upload the code to the vehicle’s controllers._

MotorControl.ino

This is the program used for both the open and obstacle challenges on an Arduino Uno R3 board. This program is compiled through the Arduino IDE software where code is also uploaded to the board through a USB cable connecting to the Arduino’s Serial port. The Arduino Uno acts as a slave controller to a Raspberry Pi 4 board with the Arduino connected to the servo motor for steering and brushless DC motor on pins 3 and 5 respectively and the Raspberry Pi connected to the camera. The Raspberry Pi will send values to the Arduino using serial communication and the Arduino will write the values to the brushless DC motor ot the servo motor. At the start of the program, the servo library is imported and servo motor objects are initialized for the servo motor and brushless DC motor. A character array, command,  is also declared which will store the values given by the Raspberry Pi. In the setup function, serial communication is started with a baud rate of 115200, and the servo objects are connected to their respective digital pins using the .attach() function. Using the write() and writeMicroseconds() functions, the servo motor is written a value of 90 turning the tires straight and the brushless DC motor is written a value of 1500, the value in which it is at rest. In the main loop of the program, A while loop checks for any serial data coming in from the Raspberry Pi. If there is serial data available, 4 bytes of data is read and stored in the command array. The char array is then converted to a 4-digit integer which the Arduino uses to write commands to the servo motor ot brushless DC motor. 

OpenChallenge.py

This program is a Python program used by a Raspberry Pi 4 board for the open challenge. The Raspberry Pi 4 was accessed through a remote access program VNC Viewer and the program was created, compiled, and uploaded to the Raspberry Pi through a Python IDE, Thonny, installed on the Raspberry Pi. This program begins by importing the necessary libraries: the OpenCV library for computer vision, the Picamera2 library to access the wide-angle camera connected to the Raspberry Pi for computer vision, the Serial library to communicate with the Arduino, the time module for delays, and the RPi.GPIO library for access to the board's GPIO pins that are needed for the push button to begin the car’s movement. The program then declares multiple functions: write() for sending motor values to the Arduino, displayROI() to show the regions of interest on screen and stopCar() to stop the car's movement and reset the servo so the wheels are straight. The program then initializes components including the camera, serial port for communicating with the Arduino, the button GPIO pins, values for proportional and derivative steering, and many values for turnings angles and speeds of the car. The program then waits 8 seconds and then waits for the button to be pressed before entering the main control loop of the program. Inside the main control loop, first, an image is captured from the camera. The image is then processed through grayscale and thresholding. After the image has been processed, contours are found in both the regions of interest to find the area of the lanes as well as being found in the entire image for debugging purposes. After the difference in areas of the lanes is found PD (proportional and derivative) steering is used to determine the angle in which to turn. The program then checks if a left or right turn should be performed by checking if either lane has an area lower than a certain threshold value and the car isn't currently in a turn going in the other direction than the lane. If there is a turn in the first iteration of the program, this indicates that the car is not actually in a turn and it is doing a sharp adjustment to get to the center of a lane as it may be placed in a side section. Then the program determines the angle to write to the Arduino to be written to the servo motor. If the boolean is indicating that the car is in a left turn or a right turn, then the angle will be set to a default turning angle going either left or right unless the previously calculated angle using PD steering indicates that the angle should be sharper in which that value is written instead. If the area of the lane the car is turning towards is above a certain threshold, then the car will exit the turn, and the variable tracking the number of turns will be incremented by one. On the other hand, if the car is not in a turn, the angle written will be the previously calculated angle unless it exceeds either of the sharpLeft or sharpRight angle values where the angle value will be rounded down to either of those values. The program then checks if the car should stop by checking if there have been 12 turns and the car is at an angle within 10 degrees of straight indicating its exited the turn area. If the conditions are true the car has completed 3 laps and will stop moving. 

